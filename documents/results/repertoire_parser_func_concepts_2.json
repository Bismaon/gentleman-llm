[
    {
        "file": "repertoire_parser.py"
    },
    {
        "name": "parse",
        "parameters": [
            [
                "source_file_path",
                "str"
            ],
            [
                "dest_path",
                "str"
            ]
        ],
        "source": "def parse(source_file_path, dest_path=None):\n\n    try:\n        # verify if the source_file_path exist\n        if not os.path.isfile(source_file_path):\n            raise ValueError(\"The file: \" + source_file_path + \"\\ndoesn't exist\")\n\n        # transform the pdf to txt using pdftotxt tools and catch the text in the stdout\n        pdftotext = subprocess.run(\n            [\"pdftotext\", \"-raw\", source_file_path.strip(), \"-\"],\n            capture_output=True,\n            text=True,  # decode to str\n            encoding=\"utf-8\",  # force UTF-8 decode\n            errors=\"replace\",  # avoid crashes on bad bytes\n            shell=False,  # no shell needed; safer & portable\n        )\n        if pdftotext.returncode != 0:\n            raise ValueError(f\"Failed to run pdftotext tool: {pdftotext.stderr}\")\n\n        # split the file into courses using the \"_____\" that separate them\n        courses = re.split(r\"_{4,}\", pdftotext.stdout)\n\n    except Exception as e:\n        logger.error(f\"Fatal : {str(e)}\")\n        sys.exit(1)\n\n    repertoire = []\n\n    for j, course in enumerate(courses):\n\n        course = course.strip()\n        lines = course.split(\"\\n\")\n        i = 0\n\n        # ------------ assure that we find a line with sigle and id\n        # look for \"Cours : 117209\" pattern pour savoir si on est sur la ligne du sigle\n        id_match = None\n        sigle_match = None\n        while i < len(lines):\n            id_match = re.search(cours_id_pattern, lines[i])\n            if id_match:  # if we find an id, we need to make sure there's also a sigle\n                sigle_match = re.search(sigle_id_pattern, lines[i])\n                if sigle_match:\n                    break  # we found both id and sigle\n            i += 1\n\n        if not id_match or not sigle_match:  # if no id and sigle found in a course\n            # Handling the end of file exception\n            if j != len(courses) - 1:  # if it's not the end of file => error\n                logger.error(\n                    f\"Error: pas de sigle+id trouvé, donc le cours suivant n'est pas processed:\\n{course}\"\n                )\n                continue\n            else:\n                break  # else its the end of file so break to terminate\n\n        name = lines[i + 1].strip()\n        # this regex detect float numbers\n        if not (\n            credit_match := re.search(\n                r\"\\(\" + float_pattern + r\"\\)\",\n                lines[i][sigle_match.end() : id_match.start()],\n            )\n        ):\n            logger.error(\n                f\"Error: pas de credit trouvé, donc -1 est attribué:\\n{lines[i]}\"\n            )\n            credit = -1.0\n        else:\n            credit = float(credit_match[0][1:-1])\n\n        i += 2  # set the index at the corect place to start description extraction\n\n        # ---------standarize the sigle:\n\n        sigle = standarize_sigle(sigle_match[0])\n\n        # --------extract course description\n\n        description = []\n        while i < len(lines):\n            line = lines[i]\n            # while we are not in an other section, we append description\n            if not re.search(stopping_string_pattern, line):\n                description.append(line)\n                i += 1\n            else:\n                break\n\n        this_course = dict()\n        repertoire.append(this_course)\n        this_course[\"_id\"] = sigle\n        this_course[\"code\"] = sigle[:3]  # IFT\n        this_course[\"number\"] = sigle[3:]  # 2015\n        this_course[\"name\"] = name\n        this_course[\"credits\"] = credit\n        this_course[\"description\"] = \" \".join(description)\n        this_course[\"available_terms\"] = {\n            \"autumn\": False,\n            \"winter\": False,\n            \"summer\": False,\n        }\n        this_course[\"available_periods\"] = {\"daytime\": False, \"evening\": False}\n\n        rest = \"\\n\".join(lines[i:])\n\n        # ----find the \"habituellement offert\" for terms availability------------\n\n        terms = this_course[\"available_terms\"]\n\n        if match := re.search(r\"[hH]abituellement ?[oO]ffert ?:\", rest):\n            # extract string until the end of line after the \":\"\n            string = rest[match.end() :].split(\"\\n\", 1)[0]\n            if re.search(r\"automne\", string.lower()):\n                terms[\"autumn\"] = True\n            if re.search(r\"hiver\", string.lower()):\n                terms[\"winter\"] = True\n            if re.search(r\"été\", string.lower()):\n                terms[\"summer\"] = True\n\n        # If no information about terms, they are arbitraly all set to True\n        if not any(terms.values()):\n            for term in [\"autumn\", \"winter\", \"summer\"]:\n                terms[term] = True\n\n        # ----find the \"attribues\" for periods availability------------\n\n        periods = this_course[\"available_periods\"]\n        if match := re.search(r\"[aA]ttributs?:\", rest):\n            # extract string until the end of line after the \":\"\n            string = rest[match.end() :].split(\"\\n\", 1)[0]\n            if re.search(r\"jour\", string.lower()):\n                periods[\"daytime\"] = True\n            if re.search(r\"soir\", string.lower()):\n                periods[\"evening\"] = True\n\n        # If no information about periods, they are arbitraly all set to True\n        if not any(periods.values()):\n            for period in [\"evening\", \"daytime\"]:\n                periods[period] = True\n\n        # --------- extract the requirements -----------------\n        # create a temporary data structure meant to be incorporate into this_course\n        requirement = {\n            \"prerequisite_courses\": set(),\n            \"concomitant_courses\": set(),\n            \"equivalent_courses\": set(),\n            \"requirement_text\": {\n                \"prerequisite_courses\": [],\n                \"equivalent_courses\": [],\n                \"concomitant_courses\": [],\n            },\n        }\n\n        while type_match := re.search(types_pattern, rest):\n            type = type_match[0]\n            if re.match(r\"[pP]réalables? ?:\", type):\n                type = \"prerequisite_courses\"\n            elif re.match(r\"[cC]oncomitants? ?:\", type):\n                type = \"concomitant_courses\"\n            elif re.match(r\"[éÉ]quivalents? ?:\", type):\n                type = \"equivalent_courses\"\n            else:\n                logger.error(\n                    f\"Error : This shouldn't ever happen, the type extracted doesn't correspond to anything\"\n                )\n                continue\n\n            # we extracted the type, we want the text after and extract just the exigences associated with this type\n            rest = rest[type_match.end() :]\n            # extract all the text until the next stopping string pattern\n            if next_rest_match := re.search(stopping_string_pattern, rest):\n                exigences_string = rest[: next_rest_match.start()]\n                rest = rest[next_rest_match.start() :]\n            else:\n                exigences_string = rest\n                rest = \"\"\n\n            all_courses = set(\n                map(standarize_sigle, re.findall(sigle_id_pattern, exigences_string))\n            )\n            requirement[type].update(all_courses)\n            requirement[\"requirement_text\"][type].append(exigences_string)\n\n        # incorporate the temp \"requirement\" dict into this_course\n        for type in [\n            \"prerequisite_courses\",\n            \"concomitant_courses\",\n            \"equivalent_courses\",\n        ]:\n            this_course[type] = list(requirement[type])\n\n        this_course[\"requirement_text\"] = \"\\n\".join(\n            [\n                type + \" : \" + \" \".join(course_list)\n                for type, course_list in requirement[\"requirement_text\"].items()\n                if len(course_list) != 0\n            ]\n        )\n\n    if dest_path is not None:\n        with open(dest_path, \"w\") as f:\n            f.write(json.dumps(repertoire))\n    return repertoire",
        "start_line": 34,
        "end_line": 237,
        "called_by": [],
        "calls": [],
        "description": "Parses a PDF file into a JSON structure of courses.",
        "tags": [
            "PDF Parsing",
            "Course Information Extraction",
            "Regex Pattern Matching",
            "Data Standardization",
            "JSON Output"
        ],
        "category": "ExternalInteraction",
        "return": [
            "repertoire",
            "list"
        ]
    }
]