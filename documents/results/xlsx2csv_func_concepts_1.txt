[
    {
        "name": "find_request_date",
        "parameters": {
            "nbr_leading_decoration_lines": "int",
            "csvfile": "any"
        },
        "source": "def find_request_date(nbr_leading_decoration_lines, csvfile):\n    for line in csvfile[: nbr_leading_decoration_lines + 1]:\n        if m := re.search(r\"(Date\\s*:\\s*)(\\d{4}-\\d{2}-\\d{2})\", line):\n            return m[2]\n    return False",
        "start_line": 19,
        "end_line": 23,
        "called_by": [
            "xlsx2csv"
        ],
        "calls": [],
        "description": "This function finds the date a specified XLSX document was fetched from syncro by searching for a specific date pattern in the document's leading lines.",
        "tags": [
            "Extracts",
            "XLSX",
            "Document",
            "Request",
            "Date"
        ],
        "category": "PureUtility",
        "return": {}
    },
    {
        "name": "xlsx2csv",
        "parameters": {
            "source_file_path": "str",
            "dest_file_path": "str"
        },
        "source": "def xlsx2csv(source_file_path, dest_file_path=None):\n\n    try:\n        # verify if the source_file_path exist\n        if not os.path.isfile(source_file_path):\n            logger.error(\"The file: \" + source_file_path + \"\\ndoesn't exist\")\n            sys.exit(1)\n\n        # Transforme the excel.xlsx to .csv\n        process_result = subprocess.run(\n            [\"xlsx2csv\", \"-d;\", source_file_path.strip()],\n            capture_output=True,\n            text=True,\n            shell=False,\n        )\n\n        if process_result.returncode != 0:\n            logger.error(\"Failed to run xlsx2csv tool\")\n            sys.exit(1)\n\n        csvfile = process_result.stdout.split(\"\\n\")\n\n    except Exception as e:\n        logger.error(f\"{str(e)}\")\n        sys.exit(1)\n\n    index_end_of_file = None\n    for i, line in enumerate(csvfile[::-1]):\n        if re.search(end_of_file_decoration, line):\n            index_end_of_file = i\n            break\n    if index_end_of_file is None:\n        logger.error(f\"No end of file found with decoration: {end_of_file_decoration}\")\n        sys.exit(1)\n\n    index_end_of_file = len(csvfile) - index_end_of_file - 1\n\n    # Find the date the file was requested on syncro\n    request_date = find_request_date(nbr_leading_decoration_lines, csvfile)\n    # If the date was not found, raise error.\n    if not request_date:\n        raise Exception(\"XLSX date was not found in \", source_file_path)\n    # cut the leading and ending decoration lines\n    csvfile = csvfile[\n        nbr_leading_decoration_lines : index_end_of_file\n        - nbr_empty_lines_on_top_of_ending_string\n    ]\n\n    # ------------ get what semestrer the csv file schedule is from----------\n\n    reader = csv.DictReader(csvfile, delimiter=\";\")\n    all_dates = []\n    counter_correct_value = 0\n    for row in reader:\n        if re.match(r\"\\d{4}-\\d{2}-\\d{2}\", row[\"Première date No. Cours\"]) and re.match(\n            r\"\\d{4}-\\d{2}-\\d{2}\", row[\"Dernière date No. Cours\"]\n        ):\n            one = date.fromisoformat(row[\"Première date No. Cours\"])\n            two = date.fromisoformat(row[\"Dernière date No. Cours\"])\n            all_dates.append(one + (two - one) // 2)  # midpoint date\n            counter_correct_value += 1\n    all_dates.sort()\n    mediane_date = all_dates[len(all_dates) // 2]\n\n    if mediane_date.month in range(1, 5):\n        sem = \"H\"\n    elif mediane_date.month in range(5, 9):\n        sem = \"E\"\n    elif mediane_date.month in range(9, 13):\n        sem = \"A\"\n    else:\n        sem = \"N\"\n\n    if mediane_date.month in [1, 5, 9, 12]:\n        logger.warning(\n            f\"mediane_date found on extrem an month, might be an error {mediane_date} in {source_file_path} with {counter_correct_value} lines\"\n        )\n\n    sem = sem + str(mediane_date.year)[2:]\n\n    # ------END OF ------ get what semestrer the csv file schedule is from------\n\n    if dest_file_path is not None:\n\n        dest_file_name = (\n            \"_\".join([\"schedule\", sem, request_date, row[\"Cheminement\"]]) + \".csv\"\n        )\n\n        dest_file_path = (\n            dest_file_path + (\"\" if dest_file_path[-1] == \"/\" else \"/\") + dest_file_name\n        )\n\n        with open(dest_file_path, \"w\", encoding=\"utf-8\") as outfile:\n            outfile.write(\"\\n\".join(csvfile))\n\n    return csvfile",
        "start_line": 26,
        "end_line": 121,
        "called_by": [],
        "calls": [
            "find_request_date"
        ],
        "description": "Converts an Excel (.xlsx) file to a CSV file, extracts the request date from the Excel file, and determines the semester the schedule is from.",
        "tags": [
            "Conversion",
            "XLSX",
            "to",
            "CSV",
            "Processing"
        ],
        "category": "ExternalInteraction",
        "return": {
            "m[2]": "list"
        }
    }
]